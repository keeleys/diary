<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<title>KEELEYS</title>
	<meta charset="utf-8">
	<!-- 引入配置文件 -->
	
<link rel="stylesheet" href="/diary/css/main.css">

	<link rel="stylesheet"
      href="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.16.2/build/styles/default.min.css">
<meta name="generator" content="Hexo 4.2.1"></head>
<body>
	<div id="main">
		<!-- 引入导航 -->
		<header>
			<div class="title">
    <a href="/diary/">KEELEYS</a>
</div>
<ul class="links">
    
    
    <li class="link">
        <a href="https://github.com/keeleys" target="_blank">Github</a>
    </li>
    
    <li class="link">
        <a href="mailto:keeley.jun@qq.com" target="_blank">Email</a>
    </li>
    
</ul>

		</header>
		<!-- 引入正文 -->
		<div id="content">
			<div id="post-header">
	<h1 id="post-author">设计模式的一点概括</h1>
	<div id="post-detail">
		<span id="post-date">2019 / 11 / 27</span>
		<span id="post-tags">
			
		</span>
	</div>
</div>

<div id="article">
	<h3 id="结构型模式一句话概括"><a href="#结构型模式一句话概括" class="headerlink" title="结构型模式一句话概括"></a>结构型模式一句话概括</h3><blockquote>
<p>结构型模式都没有改变原来的实现，通过生成新的类组合旧的类来实现扩展。</p>
</blockquote>
<ol>
<li>代理模式: 组合实现类，和实现类<code>一样的接口</code>，实现类负责核心算法，代理负责一些<code>辅助控制功能</code>。</li>
<li>适配器模式: 组合实现类，但是适配<code>新的接口</code>。</li>
<li>桥接模式: 将<code>两个接口</code>实现类<code>合并到一起</code>，一个组合另一个，将两个抽象纬度组合在一起。</li>
<li>装饰模式: 装饰类和实现类<code>一样的接口</code>，在同方法或者添加<code>新方法</code>进行<code>旧接口扩展</code>。</li>
<li>外观模式: 一个外观类统一调用多个实现类，<code>一个接口调用多个接口</code></li>
<li>享元模式: 一个类的有部分属性可以共享的时候，<code>不用重复new新对象</code>，可以用一个map享元池共享对象，然后只改变外部属性。</li>
<li>组合模式: 整体类和个体类实现同样的接口，<code>整体类用集合保存个体类</code>，计算整体的时候遍历所有个体类依次计算，可以做到类似树结构的递归遍历</li>
</ol>
<h3 id="行为模式"><a href="#行为模式" class="headerlink" title="行为模式"></a>行为模式</h3><blockquote>
<p>关注运行时的流程控制</p>
</blockquote>
<ol>
<li>模版方法: 父类实现主逻辑骨架，但差异化的代码实现定义为<code>抽象方法由子类实现</code>。</li>
<li>策略模式: 主类中定义策略类对象，然后通过组合<code>传入不同的策略类</code>的实现而达到不同的逻辑</li>
<li>命令模式: 命令也是一种策略，只不过这种命令关联了一个接受者，由<code>接受者去实现策略</code>而不是命令本身自己实现</li>
<li>责任链  : 类似link模式，一个接口关联下一个接口。从头到尾执行下去。（将任务<code>拆分成多个步骤</code>，每个链路只关注一个）</li>
<li>状态模式: 要对对象的多种状态进行不同的操作的时候，用这个模式，一个对象组合不同的状态队形，执行的时候调用状态对象执行（认识还不是很清晰）</li>
<li>观察者模式: 被观察者对象里面存一个list给观察者接口，被观察者调用需要关注的方法的时候，调用通知方法，通知所有观察者</li>
<li>中介者模式: 中介对象一对多组合普通对象，普通对象又一对一持有中介对象。普通对象调用中介接口方法的时候，中介接口转发给所有加入者，中介模式和观察者模式，就是触发事件的对象不同而已。</li>
<li>迭代器模式: 将对象里面的集合的遍历方法抽取出来，单一职责原则。</li>
<li>访问者模式: 集合对象中存在多种不同的元素，且每种元素也存在多种不同的访问者和处理方式，这种情况用。（认识还不够）</li>
<li>备忘录模式: 原对象把需要备份的属性提取到备忘录对象，由管理者对象持有备忘录对象，原对象要恢复的时候向管理者询问对象。（认识还不够）</li>
<li>解释器模式: 用来解释文本的，定义终结符类存储主体，非终结符类计算主体，由环境类统一调度。（认识还不够）</li>
</ol>
<h3 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h3><blockquote>
<p>将对象的创建与使用分离</p>
</blockquote>
<ol>
<li>单例模式: 通过私有化构造函数，同时只存在一个单例对象，节省内存</li>
<li>原型模式: 通过实现Cloneable接口，用已经存在的对象，快速复制对象</li>
<li>工厂方法模式: 由工厂统一创建单个对象</li>
<li>抽象工厂模式: 用来创建一组对象</li>
<li>建造者模式: 将对象创建需要设置的属性一个个去设置</li>
</ol>

</div>

		</div>
		<footer>
			<div class="seq20"></div>
		</footer>
	</div>
	<!-- 引入 js 文件 -->
	
<script src="/diary/js/main.js"></script>

	<script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.16.2/build/highlight.min.js"></script>
	<script>hljs.initHighlightingOnLoad();</script>
</body>
</html>